<!-- Clergy Form Panel Content with HTMX Loading -->
<div id="clergyFormContainer" style="position: relative;">
    <!-- Form submission overlay -->
    <div id="formSubmissionOverlay" class="form-submission-overlay">
        <div class="overlay-content">
            <div class="spinner"></div>
            <div class="overlay-title">Saving clergy record...</div>
            <div class="progress-container">
                <div id="formSubmissionProgressBar" class="progress-bar"></div>
            </div>
            <div id="formSubmissionProgressText" class="progress-text">0%</div>
        </div>
    </div>
    
    {% if clergy and edit_mode %}
        <!-- Load form content via HTMX for edit mode -->
        <div hx-get="{{ url_for('editor.clergy_form_content', clergy_id=clergy.id) }}" 
             hx-trigger="load" 
             hx-swap="innerHTML"
             class="form-content-loader">
            <!-- Minimal loading state -->
            <div id="formLoadingIndicatorEdit" style="padding: 1em; text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 0.8em;">
                Loading form for {{ clergy.name }}...
            </div>
        </div>
    {% elif not edit_mode %}
        <!-- Load form content via HTMX for add mode -->
        <div hx-get="{{ url_for('editor.clergy_form_content') }}" 
             hx-trigger="load" 
             hx-swap="innerHTML"
             class="form-content-loader">
            <!-- Minimal loading state -->
            <div id="formLoadingIndicatorAdd" style="padding: 1em; text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 0.8em;">
                Loading new clergy form...
            </div>
        </div>
    {% else %}
        <!-- Default state - no clergy selected -->
        <div style="padding: 2em; text-align: center; color: rgba(255, 255, 255, 0.6);">
            <div style="margin-bottom: 1em;">
                <i class="fas fa-edit" style="font-size: 3em; opacity: 0.3;"></i>
            </div>
            <h3 style="margin: 0 0 0.5em 0; font-weight: 500; color: rgba(255, 255, 255, 0.8);">No Clergy Selected</h3>
            <p style="margin: 0; font-size: 0.9em;">Select a clergy member from the list to edit, or click "Add New Clergy" to create a new record.</p>
        </div>
    {% endif %}
</div>

<!-- Enhanced form styles for editor panel with HTMX -->
<style>
/* Loading animation */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* No animations - instant updates like clergy list */

/* Form container optimization for HTMX content */
.right-panel .panel-content #clergyFormContainer {
    width: 100%;
    height: 100%;
    position: relative;
}

/* Smooth content loading */
.right-panel .form-content-loader {
    width: 100%;
    min-height: 400px;
    transition: opacity 0.3s ease, transform 0.3s ease;
}

/* Loading placeholder styling */
.right-panel .loading-placeholder {
    padding: 3em 2em;
    text-align: center;
    color: rgba(255, 255, 255, 0.6);
    position: relative;
    opacity: 1;
    transition: opacity 0.3s ease;
}

.right-panel .loading-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-top: 3px solid rgba(255, 255, 255, 0.7);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1em;
}

.right-panel .loading-spinner-small {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-top: 2px solid rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 1em auto;
}

/* Instant loading - no animations or transitions */
.right-panel .form-container {
    opacity: 1;
}

/* Simple focus styles without animation */
.right-panel input:focus,
.right-panel select:focus,
.right-panel textarea:focus {
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.2) !important;
}

/* Make the form completely seamless with the panel */
.right-panel .panel-content > div > div {
    background: transparent !important;
    backdrop-filter: none !important;
    border: none !important;
    box-shadow: none !important;
    max-width: none !important;
    margin: 0 !important;
    padding: 0 !important;
    width: 100% !important;
}

/* Ensure full width for form container */
.right-panel .panel-content #clergyFormContainer {
    width: 100% !important;
    padding: 1em !important;
}

/* Form Container Optimizations for new grid layout */
.right-panel .form-container {
    width: 100%;
}

.right-panel .form-grid {
    grid-template-columns: 1fr 1fr !important;
    gap: 0.75em !important;
    grid-auto-rows: min-content !important;
    align-items: start !important;
    height: auto !important;
}

/* Photo Section Styling */
.right-panel .photo-section {
    grid-column: 1 !important;
    grid-row: 4 / 7 !important;
    display: flex !important;
    flex-direction: column !important;
    align-self: start !important;
    justify-content: flex-start !important;
    gap: 0 !important;
}

.right-panel .photo-section .form-label {
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    margin-bottom: 0.25em !important;
}

.right-panel .photo-container {
    min-height: 200px !important;
    height: 200px !important;
    max-height: 200px !important;
    padding: 0.75em !important;
    border: 2px dashed rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    transition: border-color 0.2s ease, background-color 0.2s ease;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: center !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    margin-top: 0 !important;
}

.right-panel .photo-container.drag-over {
    border-color: rgba(255, 255, 255, 0.8);
    background-color: rgba(255, 255, 255, 0.1);
}

/* Image preview styling */
.right-panel #imagePreview {
    width: 100% !important;
    height: 100% !important;
    margin: 0 !important;
    border: 2px dashed rgba(255, 255, 255, 0.3) !important;
    border-radius: 8px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    background: rgba(255, 255, 255, 0.05) !important;
    overflow: hidden !important;
    position: relative !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    max-width: 100% !important;
    max-height: 100% !important;
}

/* When image is present, remove border and padding */
.right-panel #imagePreview.has-image {
    border: none !important;
    padding: 0 !important;
}

.right-panel #imagePreview img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    border-radius: 6px !important;
    max-width: 100% !important;
    max-height: 100% !important;
}

/* Overlay controls - positioned at bottom of image */
.right-panel .image-controls {
    position: absolute !important;
    bottom: 8px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    display: flex !important;
    gap: 6px !important;
    background: rgba(0, 0, 0, 0.7) !important;
    padding: 6px 8px !important;
    border-radius: 20px !important;
    opacity: 0 !important;
    transition: opacity 0.2s ease !important;
    z-index: 100 !important;
    pointer-events: auto !important;
}

/* Show controls on hover */
.right-panel #imagePreview:hover .image-controls {
    opacity: 1 !important;
}

.right-panel .btn-upload,
.right-panel .btn-crop,
.right-panel .btn-remove {
    width: 32px !important;
    height: 32px !important;
    padding: 0 !important;
    border-radius: 50% !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    border: none !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    font-size: 14px !important;
}

.right-panel .btn-upload:hover,
.right-panel .btn-crop:hover,
.right-panel .btn-remove:hover {
    transform: scale(1.1) !important;
}

.right-panel .btn-upload {
    background: #28a745 !important;
    color: white !important;
}

.right-panel .btn-crop {
    background: #ffc107 !important;
    color: #212529 !important;
}

.right-panel .btn-remove {
    background: #dc3545 !important;
    color: white !important;
}

.right-panel .photo-controls {
    flex-shrink: 0 !important;
    margin-top: 0.75em !important;
}

.right-panel .photo-controls button {
    padding: 0.4em 0.6em !important;
    font-size: 0.75em !important;
    margin-bottom: 0.4em !important;
}

.right-panel .photo-controls button:last-child {
    margin-bottom: 0 !important;
}

/* Form Fields Styling */
.right-panel .form-field {
    margin-bottom: 0;
    display: flex !important;
    flex-direction: column !important;
    height: auto !important;
    min-height: auto !important;
    justify-content: flex-start !important;
    align-self: start !important;
    gap: 0 !important;
}

/* Ensure form fields align properly with photo section */
.right-panel #rankField,
.right-panel #birthField,
.right-panel #deathField {
    align-items: stretch !important;
    justify-content: flex-start !important;
}

.right-panel #rankField .form-label,
.right-panel #birthField .form-label,
.right-panel #deathField .form-label {
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    margin-bottom: 0.25em !important;
    height: 1.2em !important;
    line-height: 1.2em !important;
}

/* Specific grid positioning for form fields */
.right-panel #rankField {
    grid-column: 2 !important;
    grid-row: 4 !important;
}

.right-panel #birthField {
    grid-column: 2 !important;
    grid-row: 5 !important;
}

.right-panel #deathField {
    grid-column: 2 !important;
    grid-row: 6 !important;
}

.right-panel #notesField {
    grid-column: 1 / -1 !important;
    grid-row: 7 !important;
}

.right-panel #ordinationsField {
    grid-column: 1 / -1 !important;
    grid-row: 8 !important;
}

.right-panel #consecrationsField {
    grid-column: 1 / -1 !important;
    grid-row: 9 !important;
}

.right-panel .form-field label {
    font-size: 0.8em !important;
    margin-bottom: 0.25em !important;
    font-weight: 500 !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    height: 1.2em !important;
    line-height: 1.2em !important;
}

.right-panel .photo-section label {
    font-size: 0.8em !important;
    margin-bottom: 0.25em !important;
    font-weight: 500 !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    height: 1.2em !important;
    line-height: 1.2em !important;
}

.right-panel .form-field input,
.right-panel .form-field select,
.right-panel .form-field textarea {
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    font-size: 0.85em !important;
    padding: 0.4em !important;
    border-radius: 3px !important;
    width: 100% !important;
    box-sizing: border-box !important;
    height: auto !important;
}

.right-panel .form-field textarea {
    min-height: 60px !important;
    resize: vertical !important;
}

/* Section headers */
.right-panel .form-section h5 {
    font-size: 0.9em !important;
    margin-bottom: 0.4em !important;
}

/* Section containers */
.right-panel .form-section > div {
    padding: 0.75em !important;
}

/* Dynamic entry styling */
.right-panel .ordination-entry,
.right-panel .consecration-entry {
    padding: 0.6em !important;
    margin-bottom: 0.6em !important;
}

.right-panel .ordination-entry input,
.right-panel .ordination-entry textarea,
.right-panel .ordination-entry select,
.right-panel .consecration-entry input,
.right-panel .consecration-entry textarea,
.right-panel .consecration-entry select {
    font-size: 0.75em !important;
    padding: 0.3em !important;
}

.right-panel .ordination-entry label,
.right-panel .consecration-entry label {
    font-size: 0.75em !important;
    margin-bottom: 0.2em !important;
}

/* Button styling - no animations */
.right-panel button {
    font-size: 0.8em !important;
}

.right-panel button:hover {
    background: rgba(255, 255, 255, 0.15) !important;
}

/* Admin controls styling */
.right-panel .admin-controls {
    margin-top: 1em;
    padding: 0.75em;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.05);
}

/* Submit buttons area - sticky at bottom of panel scroll; background from editor-styles.css */
.right-panel .form-actions {
    margin-top: 1em !important;
    padding-top: 0.75em !important;
    border-top: 1px solid var(--editor-border-color-medium) !important;
    position: sticky !important;
    bottom: 0 !important;
    z-index: 10;
    overflow: visible !important;
}

.right-panel .form-actions button,
.right-panel .form-actions a {
    font-size: 0.85em !important;
    padding: 0.5em 1em !important;
}

/* Prevent save button label from clipping (ensure full "Save Clergy Record" is visible) */
.right-panel .form-actions button[type="submit"],
.right-panel .form-actions .clergy-save-btn {
    overflow: visible !important;
    white-space: nowrap !important;
    min-width: 0 !important;
    flex-shrink: 0 !important;
    color: rgba(255, 255, 255, 1) !important;
}

/* Disabled save button - clear visual state */
.right-panel .form-actions button[type="submit"]:disabled {
    opacity: 0.5 !important;
    cursor: not-allowed !important;
    background: rgba(76, 175, 80, 0.08) !important;
    border-color: rgba(255, 255, 255, 0.15) !important;
    color: rgba(255, 255, 255, 0.5) !important;
}

/* Form submission overlay */
.form-submission-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    z-index: 1000;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 1em;
    color: rgba(255, 255, 255, 0.9);
}

.form-submission-overlay.active {
    display: flex;
}

.form-submission-overlay .overlay-content {
    text-align: center;
    max-width: 300px;
}

.form-submission-overlay .overlay-title {
    font-size: 1em;
    font-weight: 500;
    margin-bottom: 1em;
    color: rgba(255, 255, 255, 0.9);
}

.form-submission-overlay .progress-container {
    width: 100%;
    max-width: 300px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    overflow: hidden;
    height: 8px;
    margin-bottom: 0.5em;
}

.form-submission-overlay .progress-bar {
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 4px;
    transition: width 0.3s ease;
    width: 0%;
}

.form-submission-overlay .progress-text {
    font-size: 0.85em;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 0.5em;
}

.form-submission-overlay .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-top: 3px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1em;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}


/* Responsive adjustments for smaller panels */
@media (max-width: 1200px) {
    .right-panel .form-grid {
        grid-template-columns: 1fr 1fr !important;
        gap: 0.6em !important;
    }
    
    .right-panel .photo-section {
        min-height: 240px;
        height: 100%;
    }
    
    .right-panel .photo-container {
        min-height: 180px !important;
        height: 100%;
    }
    
    .right-panel .photo-controls button {
        padding: 0.3em 0.5em !important;
        font-size: 0.7em !important;
    }
    
    .right-panel .form-field {
        height: 100% !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: space-between !important;
    }
    
    .right-panel .form-field input,
    .right-panel .form-field select,
    .right-panel .form-field textarea {
        font-size: 0.8em !important;
        padding: 0.35em !important;
    }
}
</style>

<script>
// Simple form handling - instant updates like clergy list
document.addEventListener('DOMContentLoaded', function() {
    // Initialize drag and drop and cancel button immediately
    initializeDragDropForHTMX();
    initializeCancelButtonHandler();
    initializePhotoControls();
    
    // Set up mutation observer to watch for form content changes
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'childList') {
                // Check if clergy form was added
                const addedNodes = Array.from(mutation.addedNodes);
                const hasClergyForm = addedNodes.some(node => 
                    node.nodeType === Node.ELEMENT_NODE && 
                    (node.id === 'clergyForm' || node.querySelector('#clergyForm'))
                );
                
                if (hasClergyForm) {
                    setTimeout(() => {
                        initializeDragDropForHTMX();
                        initializeCancelButtonHandler();
                        initializePhotoControls();
                    }, 100);
                }
            }
        });
    });
    
    // Start observing
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
    
    // Also set up a periodic check as a fallback
    setInterval(() => {
        const clergyForm = document.querySelector('#clergyForm');
        const photoContainer = document.querySelector('#photoContainer');
        
        if (clergyForm && photoContainer && !photoContainer.hasAttribute('data-drag-drop-initialized')) {
            initializeDragDropForHTMX();
            initializeCancelButtonHandler();
            initializePhotoControls();
        }
    }, 1000); // Check every second
});

// Note: Form submission is now handled globally by clergy-form-submission.js
// The global handler uses event delegation and will catch all clergy form submissions

// Bishop creation functions for editor form
function collectBishopNames(form) {
    const bishopNames = new Set();
    
    // Collect ordaining bishops
    const ordainingBishopInputs = form.querySelectorAll('input[name*="ordaining_bishop_input"]');
    ordainingBishopInputs.forEach(input => {
        const name = input.value.trim();
        const idInput = input.parentElement.querySelector('input[name*="ordaining_bishop_id"]');
        const id = idInput ? idInput.value : '';
        if (name && !id) {
            bishopNames.add(name);
        }
    });
    
    // Collect consecrators
    const consecratorInputs = form.querySelectorAll('input[name*="consecrator_input"]');
    consecratorInputs.forEach(input => {
        const name = input.value.trim();
        const idInput = input.parentElement.querySelector('input[name*="consecrator_id"]');
        const id = idInput ? idInput.value : '';
        if (name && !id) {
            bishopNames.add(name);
        }
    });
    
    // Collect co-consecrators
    const coConsecratorInputs = form.querySelectorAll('input[name*="co_consecrators"][name*="input"]');
    coConsecratorInputs.forEach(input => {
        const name = input.value.trim();
        const idInput = input.parentElement.querySelector('input[name*="id"]');
        const id = idInput ? idInput.value : '';
        if (name && !id) {
            bishopNames.add(name);
        }
    });
    
    return Array.from(bishopNames);
}

function checkAndCreateBishops(bishopNames) {
    return new Promise((resolve, reject) => {
        // Send AJAX request to check and create bishops
        fetch('/api/check-and-create-bishops', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                bishop_names: bishopNames
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                updateFormWithBishopIds(data.bishop_mapping);
                resolve(data);
            } else {
                reject(new Error(data.message || 'Failed to create bishops'));
            }
        })
        .catch(error => {
            console.error('Error creating bishops:', error);
            reject(error);
        });
    });
}

function updateFormWithBishopIds(bishopMapping) {
    const form = document.getElementById('clergyForm');
    if (!form) return;
    
    // Update ordaining bishops
    const ordainingBishopInputs = form.querySelectorAll('input[name*="ordaining_bishop_input"]');
    ordainingBishopInputs.forEach(input => {
        const name = input.value.trim();
        if (bishopMapping[name]) {
            const idInput = input.parentElement.querySelector('input[name*="ordaining_bishop_id"]');
            if (idInput) {
                idInput.value = bishopMapping[name];
            }
        }
    });
    
    // Update consecrators
    const consecratorInputs = form.querySelectorAll('input[name*="consecrator_input"]');
    consecratorInputs.forEach(input => {
        const name = input.value.trim();
        if (bishopMapping[name]) {
            const idInput = input.parentElement.querySelector('input[name*="consecrator_id"]');
            if (idInput) {
                idInput.value = bishopMapping[name];
            }
        }
    });
    
    // Update co-consecrators
    const coConsecratorInputs = form.querySelectorAll('input[name*="co_consecrators"][name*="input"]');
    coConsecratorInputs.forEach(input => {
        const name = input.value.trim();
        if (bishopMapping[name]) {
            const idInput = input.parentElement.querySelector('input[name*="id"]');
            if (idInput) {
                idInput.value = bishopMapping[name];
            }
        }
    });
}

function resetSubmitButton(button, originalTextOrHTML) {
    if (originalTextOrHTML && originalTextOrHTML.includes && originalTextOrHTML.includes('<')) {
        button.innerHTML = originalTextOrHTML;
    } else {
        button.textContent = originalTextOrHTML || 'Save Clergy Record';
    }
    button.disabled = false;
}

// Note: Overlay functions are now in clergy-form-overlay.js (loaded globally)
// Use window.showFormSubmissionOverlay(), window.hideFormSubmissionOverlay(), window.updateFormSubmissionProgress()

// Spritesheet polling functions (use window so inline script can run again on HTMX swap)
if (typeof window.spritesheetPollingInterval === 'undefined') {
    window.spritesheetPollingInterval = null;
}

function startSpritesheetPolling(clergyId) {
    // Clear any existing polling
    if (window.spritesheetPollingInterval) {
        clearInterval(window.spritesheetPollingInterval);
    }
    
    let pollCount = 0;
    const maxPolls = 60; // Poll for up to 60 seconds (1 second intervals)
    
    window.spritesheetPollingInterval = setInterval(() => {
        pollCount++;
        
        fetch('/api/sprite-sheet-status')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.status === 'completed') {
                    // Spritesheet generation completed
                    clearInterval(window.spritesheetPollingInterval);
                    window.spritesheetPollingInterval = null;
                    
                    // Show success notification
                    if (typeof window.showNotification === 'function') {
                        window.showNotification('Images updated!', 'success');
                    }
                    
                    // Soft refresh visualization and clergy list
                    refreshVisualizationSpritesheet(data);
                    refreshClergyListImages(data);
                } else if (data.success && data.status === 'error') {
                    // Error occurred
                    clearInterval(window.spritesheetPollingInterval);
                    window.spritesheetPollingInterval = null;
                    
                    console.error('Spritesheet generation error:', data.error);
                    if (typeof window.showNotification === 'function') {
                        window.showNotification('Spritesheet generation failed: ' + (data.error || 'Unknown error'), 'error');
                    }
                }
                // If status is 'in_progress' or 'idle', continue polling
            })
            .catch(error => {
                console.error('Error polling spritesheet status:', error);
                // Continue polling on error
            });
        
        // Stop polling after max attempts
        if (pollCount >= maxPolls) {
            clearInterval(window.spritesheetPollingInterval);
            window.spritesheetPollingInterval = null;
            console.warn('Spritesheet polling timeout - generation may still be in progress');
        }
    }, 1000); // Poll every second
}

function refreshVisualizationSpritesheet(spriteData) {
    // Invalidate cache since we have new sprite data
    if (typeof window.invalidateSpriteSheetCache === 'function') {
        window.invalidateSpriteSheetCache();
    }
    
    // Update visualization spritesheet without full reload
    if (window.editorVisualization && typeof window.editorVisualization.updateSpritesheet === 'function') {
        console.log('Updating visualization spritesheet with new data');
        window.editorVisualization.updateSpritesheet(spriteData);
    } else {
        console.log('Visualization not available, fetching latest spritesheet data');
        // Use cache utility if available, otherwise fallback to direct fetch
        if (typeof window.refreshSpriteSheetData === 'function') {
            window.refreshSpriteSheetData()
                .then(data => {
                    if (data && data.success && window.editorVisualization && typeof window.editorVisualization.updateSpritesheet === 'function') {
                        window.editorVisualization.updateSpritesheet(data);
                    } else {
                        // Last resort: soft refresh of the visualization
                        if (typeof window.softRefreshVisualization === 'function') {
                            window.softRefreshVisualization();
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing visualization spritesheet:', error);
                });
        } else {
            // Fallback to direct fetch
            fetch('/api/sprite-sheet')
                .then(response => response.json())
                .then(data => {
                    if (data.success && window.editorVisualization && typeof window.editorVisualization.updateSpritesheet === 'function') {
                        window.editorVisualization.updateSpritesheet(data);
                    } else {
                        // Last resort: soft refresh of the visualization
                        if (typeof window.softRefreshVisualization === 'function') {
                            window.softRefreshVisualization();
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing visualization spritesheet:', error);
                });
        }
    }
}

function refreshClergyListImages(spriteData) {
    // Update clergy list images after spritesheet generation
    // Soft refresh: update only image elements with cache-busting URLs
    console.log('Refreshing clergy list images after spritesheet update');
    
    const clergyItems = document.querySelectorAll('.clergy-item-card');
    
    clergyItems.forEach(item => {
        const clergyId = item.getAttribute('data-clergy-id');
        if (!clergyId) return;
        
        const photoContainer = item.querySelector('.clergy-item-photo');
        if (!photoContainer) return;
        
        // Update sprite-based images if sprite sheet data is available
        if (spriteData && spriteData.mapping) {
            const spriteDiv = photoContainer.querySelector('.clergy-item-photo-sprite');
            if (spriteDiv && spriteData.mapping[clergyId]) {
                // Update sprite background image URL with cache-busting
                const currentStyle = spriteDiv.style.backgroundImage;
                if (currentStyle && currentStyle.includes('url(')) {
                    const urlMatch = currentStyle.match(/url\(['"]?([^'"]+)['"]?\)/);
                    if (urlMatch && urlMatch[1]) {
                        const urlStr = urlMatch[1];
                        if (!urlStr.startsWith('data:')) {
                            const url = new URL(urlStr);
                            url.searchParams.set('_t', Date.now());
                            spriteDiv.style.backgroundImage = `url('${url.toString()}')`;
                        }
                    }
                }
            }
        }
        
        // Update regular img elements with cache-busting
        const photoElement = photoContainer.querySelector('img');
        if (photoElement && photoElement.src) {
            if (photoElement.src.startsWith('data:')) return;
            try {
                const url = new URL(photoElement.src);
                url.searchParams.set('_t', Date.now());
                photoElement.src = url.toString();
            } catch (e) {
                // If URL parsing fails, just add timestamp as query param
                const separator = photoElement.src.includes('?') ? '&' : '?';
                photoElement.src = photoElement.src + separator + '_t=' + Date.now();
            }
        }
    });
    
    // Re-initialize clergy data for filtering
    if (typeof initializeClergyData === 'function') {
        initializeClergyData();
    }
    
    console.log('Clergy list images refreshed');
}

// Soft update: add or update a single clergy item in the list
async function softUpdateClergyListItem(clergyId) {
    if (!clergyId) return;
    
    console.log('Soft updating clergy list item:', clergyId);
    
    // Check if item already exists
    const existingItem = document.querySelector(`[data-clergy-id="${clergyId}"]`);
    
    if (existingItem) {
        // Item exists - update it by fetching just that item's HTML
        // We'll use HTMX to fetch a partial update
        // For now, do a minimal refresh of just that section
        // Since we don't have an endpoint for single item, we'll update the whole list
        // but only if the item is visible (not filtered out)
        const isVisible = existingItem.style.display !== 'none';
        if (isVisible) {
            // Just refresh images with cache-busting
            const photoContainer = existingItem.querySelector('.clergy-item-photo');
            if (photoContainer) {
                const img = photoContainer.querySelector('img');
                const sprite = photoContainer.querySelector('.clergy-item-photo-sprite');
                if (img && img.src) {
                    if (!img.src.startsWith('data:')) {
                    try {
                        const url = new URL(img.src);
                        url.searchParams.set('_t', Date.now());
                        img.src = url.toString();
                    } catch (e) {
                        const separator = img.src.includes('?') ? '&' : '?';
                        img.src = img.src + separator + '_t=' + Date.now();
                    }
                    }
                }
                if (sprite && sprite.style.backgroundImage) {
                    const urlMatch = sprite.style.backgroundImage.match(/url\(['"]?([^'"]+)['"]?\)/);
                    if (urlMatch && urlMatch[1] && !urlMatch[1].startsWith('data:')) {
                        try {
                            const url = new URL(urlMatch[1]);
                            url.searchParams.set('_t', Date.now());
                            sprite.style.backgroundImage = `url('${url.toString()}')`;
                        } catch (e) {
                            // Skip if URL parsing fails
                        }
                    }
                }
            }
        }
    } else {
        // Item doesn't exist - need to add it
        // Do a full refresh but only if we're not filtering
        const searchInput = document.getElementById('clergySearchInput');
        const showDeleted = document.getElementById('showDeleted');
        const excludePriests = document.getElementById('excludePriests');
        
        const hasFilters = (searchInput && searchInput.value.trim()) || 
                          (showDeleted && showDeleted.checked) ||
                          (excludePriests && excludePriests.checked);
        
        if (!hasFilters) {
            // No filters active - safe to do full refresh
            const clergyListTarget = document.querySelector('.left-panel .panel-content');
            if (clergyListTarget && typeof htmx !== 'undefined') {
                htmx.ajax('GET', '/editor/clergy-list', {
                    target: clergyListTarget,
                    swap: 'innerHTML'
                }).then(() => {
                    // Re-initialize data and re-highlight
                    if (typeof initializeClergyData === 'function') {
                        initializeClergyData();
                    }
                    if (window.currentSelectedClergyId && typeof window.highlightClergyInList === 'function') {
                        window.highlightClergyInList(window.currentSelectedClergyId);
                    }
                });
            }
        }
    }
}

function submitFormWithData(form, formData, submitBtn, originalText) {
    // Show overlay with clear message using global functions
    if (typeof window.showFormSubmissionOverlay === 'function') {
        window.showFormSubmissionOverlay();
    }
    if (typeof window.updateFormSubmissionProgress === 'function') {
        window.updateFormSubmissionProgress(20, 'Submitting form...');
    }
    
    // Debug: Log form data contents
    console.log('=== FORM SUBMISSION DEBUG ===');
    console.log('Form action:', form.action);
    console.log('Form method:', form.method);
    console.log('Form enctype:', form.enctype);
    
    // Check file input
    const fileInput = form.querySelector('input[name="clergy_image"]');
    if (fileInput) {
        console.log('File input found:', fileInput);
        console.log('File input files:', fileInput.files);
        console.log('File input files length:', fileInput.files.length);
        if (fileInput.files.length > 0) {
            console.log('File to upload:', fileInput.files[0]);
        }
    } else {
        console.log('File input NOT found!');
    }
    
    // Check for globally stored dropped file
    if (window.droppedFile) {
        console.log('Globally stored file found:', window.droppedFile);
        console.log('Adding dropped file to FormData...');
        formData.append('clergy_image', window.droppedFile);
        // Clear the global file after adding to form data
        delete window.droppedFile;
    }
    
    // Check for processed image data from image editor
    if (window.processedImageData) {
        console.log('Processed image data found:', window.processedImageData);
        console.log('Adding processed image data to FormData...');
        formData.append('image_data_json', JSON.stringify(window.processedImageData));
        // Clear the processed image data after adding to form data
        delete window.processedImageData;
    }
    
    // Log all form data entries
    console.log('FormData entries:');
    for (let [key, value] of formData.entries()) {
        if (value instanceof File) {
            console.log(`  ${key}: File(${value.name}, ${value.size} bytes, ${value.type})`);
        } else {
            console.log(`  ${key}: ${value}`);
        }
    }
    console.log('=== END FORM SUBMISSION DEBUG ===');
    
    if (typeof window.updateFormSubmissionProgress === 'function') {
        window.updateFormSubmissionProgress(40, 'Uploading data...');
    }
    
    // Submit via fetch
    fetch(form.action, {
        method: 'POST',
        body: formData,
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    })
        .then(response => {
            if (typeof window.updateFormSubmissionProgress === 'function') {
                window.updateFormSubmissionProgress(70, 'Processing response...');
            }
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (typeof window.updateFormSubmissionProgress === 'function') {
                window.updateFormSubmissionProgress(90, 'Finalizing...');
            }
            
            if (data.success) {
                // Success - soft refresh panels
                if (data.clergy_id) {
                    softUpdateClergyListItem(data.clergy_id);
                }
                
                const markDeletedCheckbox = form.querySelector('input[name="mark_deleted"]');
                const wasMarkedDeleted = markDeletedCheckbox && markDeletedCheckbox.checked;
                
                const hideOverlayAndResetButton = () => {
                    if (typeof window.hideFormSubmissionOverlay === 'function') {
                        window.hideFormSubmissionOverlay();
                    }
                    if (submitBtn) {
                        const orig = submitBtn._originalHtml || (submitBtn.dataset && submitBtn.dataset.originalHtml) || originalText;
                        if (typeof window.resetSubmitButton === 'function') {
                            window.resetSubmitButton(submitBtn, orig);
                        } else {
                            submitBtn.innerHTML = orig;
                            submitBtn.disabled = false;
                        }
                    }
                };
                
                if (wasMarkedDeleted) {
                    clearFormForNewEntry().then(hideOverlayAndResetButton).catch(hideOverlayAndResetButton);
                    showNotification('Record marked for deletion. Form cleared for new entry.', 'info');
                } else if (data.clergy_id) {
                    switchToEditMode(data.clergy_id).then(hideOverlayAndResetButton).catch(hideOverlayAndResetButton);
                    showNotification('Clergy record saved successfully!', 'success');
                    document.body.dispatchEvent(new CustomEvent('clergyUpdated', {
                        detail: { clergyId: data.clergy_id, action: 'updated' }
                    }));
                } else {
                    hideOverlayAndResetButton();
                    showNotification('Clergy record saved successfully!', 'success');
                    document.body.dispatchEvent(new CustomEvent('clergyUpdated', {
                        detail: { action: 'created' }
                    }));
                }
                
                if (data.clergy_id) {
                    startSpritesheetPolling(data.clergy_id);
                }
                
            } else {
                throw new Error(data.message || 'Failed to save clergy record');
            }
        })
        .catch(error => {
            console.error('Form submission error:', error);
            if (error instanceof SyntaxError) {
                console.error('JSON parsing error - response was not valid JSON');
                showNotification('Error: Server returned invalid response', 'error');
            } else {
                showNotification('Error saving record: ' + error.message, 'error');
            }
            if (typeof window.hideFormSubmissionOverlay === 'function') {
                window.hideFormSubmissionOverlay();
            }
            if (submitBtn) {
                const orig = submitBtn._originalHtml || (submitBtn.dataset && submitBtn.dataset.originalHtml) || originalText;
                if (typeof window.resetSubmitButton === 'function') {
                    window.resetSubmitButton(submitBtn, orig);
                } else {
                    submitBtn.innerHTML = orig;
                    submitBtn.disabled = false;
                }
            }
        });
}

// HTMX event handling with form initialization
document.body.addEventListener('htmx:afterSwap', function(evt) {
    // Use evt.detail.target for swap target (htmx.ajax), fallback to evt.target
    const swapTarget = (evt.detail && evt.detail.target) || evt.target;
    const isClergyFormContainer = swapTarget.closest('#clergyFormContainer');
    const isFormContentLoader = swapTarget.classList && swapTarget.classList.contains('form-content-loader');
    const containsClergyForm = swapTarget.querySelector && swapTarget.querySelector('#clergyForm');
    const isClergyForm = swapTarget.id === 'clergyForm';
    const isPanelContent = swapTarget.classList && swapTarget.classList.contains('panel-content');
    
    if (isClergyFormContainer || isFormContentLoader || containsClergyForm || isClergyForm || isPanelContent) {
        const clergyForm = swapTarget.querySelector('#clergyForm') || (swapTarget.id === 'clergyForm' ? swapTarget : null);
        if (!clergyForm) {
            return;
        }
        
        console.log('HTMX afterSwap: Clergy form detected');
        
        // NOTE: We do NOT clear form state here because the form has just been loaded with NEW data
        // Clearing was already done in selectClergy() BEFORE the HTMX request was made
        // If we clear here, we would be clearing the newly loaded data, which is wrong
        
        // Initialize the form FIRST to populate data, THEN initialize embedded script
        // This ensures data is populated before any clearing happens
        setTimeout(function() {
            // Initialize the form FIRST - this populates ordinations/consecrations
            // Check if we have initialization functions available
            if (typeof window.initializeFormFromRank === 'function') {
                console.log('HTMX afterSwap: Calling initializeFormFromRank FIRST (to populate data)');
                window.initializeFormFromRank();
            } else {
                // Initialize directly if the functions are in the loaded content
                const rankSelect = document.getElementById('rank');
                if (rankSelect && rankSelect.value) {
                    console.log('HTMX afterSwap: Triggering rank change event');
                    rankSelect.dispatchEvent(new Event('change'));
                }
            }
            
            // THEN initialize embedded form script (which no longer clears form state)
            // This ensures data is already populated before any other initialization
            setTimeout(function() {
                if (typeof window.initializeEmbeddedFormScript === 'function') {
                    console.log('HTMX afterSwap: Calling initializeEmbeddedFormScript AFTER data population');
                    window.initializeEmbeddedFormScript();
                } else {
                    console.warn('HTMX afterSwap: initializeEmbeddedFormScript not available');
                }
            }, 10);
        }, 50);
        
        // Additional initialization to ensure consecration field is shown for bishops
        setTimeout(() => {
            console.log('ðŸ” HTMX TIMEOUT: Starting HTMX consecration field check');
            const rankSelect = document.getElementById('rank');
            const consecrationsField = document.getElementById('consecrationsField');
            
            console.log('ðŸ” HTMX TIMEOUT: rankSelect found =', !!rankSelect);
            console.log('ðŸ” HTMX TIMEOUT: consecrationsField found =', !!consecrationsField);
            
            if (rankSelect && consecrationsField) {
                const selectedOption = rankSelect.options[rankSelect.selectedIndex];
                const isBishop = selectedOption && selectedOption.getAttribute('data-is-bishop') === 'true';
                
                console.log('ðŸ” HTMX TIMEOUT: Checking bishop status:', {
                    rankValue: rankSelect.value,
                    isBishop: isBishop,
                    consecrationsField: !!consecrationsField,
                    selectedOption: selectedOption ? selectedOption.textContent : 'none',
                    dataAttribute: selectedOption ? selectedOption.getAttribute('data-is-bishop') : 'none'
                });
                
                if (isBishop) {
                    consecrationsField.style.display = 'block';
                    console.log('ðŸ” HTMX TIMEOUT: âœ… Showing consecrations field for bishop rank');
                    
                    // Also try to populate consecrations if in edit mode
                    const clergyForm = document.getElementById('clergyForm');
                    if (clergyForm && clergyForm.dataset.editMode === 'true') {
                        console.log('ðŸ” HTMX TIMEOUT: About to call populateExistingConsecrations() from HTMX timeout');
                        if (typeof populateExistingConsecrations === 'function') {
                            populateExistingConsecrations();
                        } else {
                            console.error('âŒ HTMX TIMEOUT: populateExistingConsecrations function not found');
                        }
                    }
                } else {
                    console.log('ðŸ” HTMX TIMEOUT: âŒ Not a bishop rank, not showing consecrations field');
                }
            } else {
                console.log('ðŸ” HTMX TIMEOUT: âŒ Missing required elements - rankSelect:', !!rankSelect, 'consecrationsField:', !!consecrationsField);
            }
        }, 100);
        
        // Initialize photo controls
        console.log('HTMX afterSwap: Initializing photo controls');
        initializePhotoControls();
        
        // Initialize clergy autocomplete for HTMX-loaded content
        
        // Wait a bit for the embedded form script to load
        setTimeout(() => {
            if (typeof window.initializeClergyAutocomplete === 'function') {
                window.initializeClergyAutocomplete();
            } else if (typeof window.initializeSingleClergyAutocomplete === 'function') {
                const clergyInputs = document.querySelectorAll('input[name*="ordaining_bishop_input"], input[name*="consecrator_input"], input[name*="co_consecrators"][name*="input"]');
                clergyInputs.forEach(input => {
                    if (!input.hasAttribute('data-autocomplete-initialized')) {
                        window.initializeSingleClergyAutocomplete(input);
                    }
                });
            } else {
                // Direct initialization as last resort
                const clergyInputs = document.querySelectorAll('input[name*="ordaining_bishop_input"], input[name*="consecrator_input"], input[name*="co_consecrators"][name*="input"]');
                clergyInputs.forEach(input => {
                    if (!input.hasAttribute('data-autocomplete-initialized')) {
                        // Direct initialization logic here
                        initializeClergyAutocompleteDirect(input);
                    }
                });
            }
            
            // Re-initialize drag and drop functionality for HTMX-loaded content
            initializeDragDropForHTMX();
            
            // Initialize cancel button handler for HTMX-loaded content
            initializeCancelButtonHandler();
            
            // Initialize photo controls
            console.log('HTMX timeout: Initializing photo controls');
            initializePhotoControls();
        }, 200);
    }
});

// Additional HTMX event handler for afterRequest
document.body.addEventListener('htmx:afterRequest', function(evt) {
    // Check if this was a clergy form content request
    const isClergyFormContentRequest = evt.detail.xhr && evt.detail.xhr.responseURL && 
        (evt.detail.xhr.responseURL.includes('/editor/clergy-form-content') || 
         evt.detail.xhr.responseURL.includes('/editor/clergy-form/'));
    
    if (isClergyFormContentRequest) {
        // Wait a bit for the content to be swapped
        setTimeout(() => {
            const clergyForm = document.querySelector('#clergyForm');
            if (clergyForm) {
                initializeDragDropForHTMX();
                initializeCancelButtonHandler();
                
                // Initialize photo controls
                console.log('HTMX afterRequest: Initializing photo controls');
                initializePhotoControls();
            }
        }, 100);
    }
});

// Initialize cancel button handler for HTMX-loaded content
function initializeCancelButtonHandler() {
    const cancelBtn = document.getElementById('cancel-btn');
    
    if (cancelBtn) {
        // Check if already initialized
        if (cancelBtn.hasAttribute('data-cancel-initialized')) {
            return;
        }
        
        // Mark as initialized
        cancelBtn.setAttribute('data-cancel-initialized', 'true');
        
        cancelBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Clear the form and switch to add mode
            clearFormForNewEntry();
        });
    }
}

// Initialize photo control buttons for HTMX-loaded content
function initializePhotoControls() {
    console.log('=== initializePhotoControls START ===');
    
    // Check if required elements exist
    const imageInput = document.getElementById('clergyImage');
    const uploadBtn = document.getElementById('uploadBtn');
    const cropBtn = document.getElementById('cropExistingBtn');
    const removeBtn = document.getElementById('removeImageBtn');
    
    console.log('Photo control elements found:', {
        imageInput: !!imageInput,
        uploadBtn: !!uploadBtn,
        cropBtn: !!cropBtn,
        removeBtn: !!removeBtn
    });
    
    // Ensure image editor is available
    if (!window.imageEditor && typeof ImageEditor !== 'undefined') {
        console.log('Creating new ImageEditor instance for photo controls');
        try {
            window.imageEditor = new ImageEditor();
            console.log('ImageEditor instance created successfully');
        } catch (error) {
            console.error('Error creating ImageEditor instance:', error);
            return;
        }
    } else if (!window.imageEditor) {
        console.warn('ImageEditor class not available');
        return;
    }
    
    // Reattach form event listeners for photo controls
    if (window.imageEditor && typeof window.imageEditor.reattachFormEventListeners === 'function') {
        console.log('Reattaching form event listeners for photo controls');
        try {
            window.imageEditor.reattachFormEventListeners();
            console.log('Form event listeners reattached successfully');
        } catch (error) {
            console.error('Error reattaching form event listeners:', error);
        }
    } else {
        console.warn('reattachFormEventListeners method not available');
    }
    
    console.log('=== initializePhotoControls END ===');
}

// Initialize drag and drop functionality for HTMX-loaded content
function initializeDragDropForHTMX() {
    const photoContainer = document.getElementById('photoContainer');
    const fileInput = document.getElementById('clergyImage');
    
    if (photoContainer && fileInput) {
        // Check if drag and drop is already initialized
        if (photoContainer.hasAttribute('data-drag-drop-initialized')) {
            return;
        }
        
        // Mark as initialized
        photoContainer.setAttribute('data-drag-drop-initialized', 'true');
        
        // Handle existing image in edit mode - make it not interfere with drag events
        const existingImage = photoContainer.querySelector('#previewImage');
        if (existingImage) {
            existingImage.style.pointerEvents = 'none';
            
            // Also add drag event handlers to the image itself as a fallback
            existingImage.addEventListener('dragenter', function(e) {
                e.preventDefault();
                e.stopPropagation();
                photoContainer.classList.add('drag-over');
            }, true);
            
            existingImage.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
            }, true);
            
            existingImage.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                photoContainer.classList.remove('drag-over');
            }, true);
            
            existingImage.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                photoContainer.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    
                    if (file.type.startsWith('image/')) {
                        // Check file size (25MB limit)
                        if (file.size > 25 * 1024 * 1024) {
                            alert('File size exceeds 25MB limit. Please choose a smaller image.');
                            return;
                        }
                        
                        try {
                            // Store the file globally for form submission
                            window.droppedFile = file;
                            console.log('File stored globally:', file.name, file.size, file.type);
                            
                            // Try to set the file in the input element
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(file);
                            fileInput.files = dataTransfer.files;
                            console.log('File set in input element using DataTransfer');
                            
                            // Trigger the image editor if available
                            if (window.imageEditor && typeof window.imageEditor.handleFormImageUpload === 'function') {
                                const syntheticEvent = {
                                    target: fileInput,
                                    preventDefault: function() {},
                                    stopPropagation: function() {}
                                };
                                window.imageEditor.handleFormImageUpload(syntheticEvent);
                            } else {
                                // Fallback to simple preview
                                const reader = new FileReader();
                                reader.onload = function(e) {
                                    const imagePreview = document.getElementById('imagePreview');
                                    if (imagePreview) {
                                        imagePreview.innerHTML = `
                                            <img src="${e.target.result}" alt="Preview" id="previewImage" 
                                                 style="max-width: 150px; max-height: 150px; border-radius: 4px; object-fit: cover;">
                                        `;
                                    }
                                };
                                reader.readAsDataURL(file);
                            }
                        } catch (error) {
                            console.error('Error processing file from image drop:', error);
                        }
                    } else {
                        alert('Please select an image file.');
                    }
                }
            }, true);
        }
        
        // Direct drag and drop handlers with event delegation for child elements
        photoContainer.addEventListener('dragenter', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        }, true);
        
        photoContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
        }, true);
        
        photoContainer.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            // Only remove drag-over if we're actually leaving the container
            if (!this.contains(e.relatedTarget)) {
                this.classList.remove('drag-over');
            }
        }, true);
        
        photoContainer.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            
            const file = e.dataTransfer.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file.');
                return;
            }

            // Store file globally and in input
            window.droppedFile = file;
            
            try {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;
            } catch (error) {
                console.error('Error setting file in input:', error);
            }

            // Handle image preview/editing
            if (window.imageEditor?.handleFormImageUpload) {
                const syntheticEvent = {
                    target: fileInput,
                    preventDefault: () => {},
                    stopPropagation: () => {}
                };
                window.imageEditor.handleFormImageUpload(syntheticEvent);
            } else {
                // Simple preview fallback
                const reader = new FileReader();
                reader.onload = (e) => {
                    const imagePreview = document.getElementById('imagePreview');
                    if (imagePreview) {
                        imagePreview.innerHTML = `
                            <img src="${e.target.result}" alt="Preview" id="previewImage" 
                                 style="max-width: 150px; max-height: 150px; border-radius: 4px; object-fit: cover;">
                        `;
                    }
                };
                reader.readAsDataURL(file);
            }
        }, true);
    }
}

// Switch form to edit mode after saving a new clergy record. Returns a Promise that resolves when the form swap completes.
function switchToEditMode(clergyId) {
    if (typeof window.selectClergy === 'function') {
        return window.selectClergy(clergyId);
    }
    console.error('selectClergy function not found, falling back to manual approach');
    return htmx.ajax('GET', `/editor/clergy-form-content/${clergyId}`, {
        target: '.right-panel .panel-content',
        swap: 'innerHTML'
    }).then(() => {
        window.currentSelectedClergyId = clergyId;
        if (typeof window.clearGlobalFormState === 'function') {
            window.clearGlobalFormState();
        }
    });
}

// Clear form and switch to add mode after deletion. Returns a Promise that resolves when the form swap completes.
function clearFormForNewEntry() {
    if (typeof window.clearGlobalFormState === 'function') {
        window.clearGlobalFormState();
    }
    if (typeof window.clearClergyHighlights === 'function') {
        window.clearClergyHighlights();
    }
    if (typeof window.selectClergy === 'function') {
        return window.selectClergy(null);
    }
    console.error('selectClergy function not found, falling back to manual approach');
    return htmx.ajax('GET', '/editor/clergy-form-content', {
        target: '.right-panel .panel-content',
        swap: 'innerHTML'
    }).then(() => {
        if (typeof window.clearGlobalFormState === 'function') {
            window.clearGlobalFormState();
        }
    });
}

// Simple instant refresh function
function refreshClergyForm(clergyId = null) {
    const container = document.querySelector('#clergyFormContainer .form-content-loader');
    if (!container) return;
    
    const url = clergyId ? 
        `/editor/clergy-form-content/${clergyId}` : 
        '/editor/clergy-form-content';
    
    // Instant HTMX load - no transitions
    htmx.ajax('GET', url, {
        target: container,
        swap: 'innerHTML'
    });
}

// Make functions globally available
window.refreshClergyFormSmooth = refreshClergyForm;
window.switchToEditMode = switchToEditMode;
window.clearFormForNewEntry = clearFormForNewEntry;
window.initializeDragDropForHTMX = initializeDragDropForHTMX;
window.initializeCancelButtonHandler = initializeCancelButtonHandler;
window.initializePhotoControls = initializePhotoControls;
window.softUpdateClergyListItem = softUpdateClergyListItem;
window.refreshClergyListImages = refreshClergyListImages;
window.submitFormWithData = submitFormWithData; // Editor-specific submission handler with soft updates
window.startSpritesheetPolling = startSpritesheetPolling; // Make spritesheet polling available globally

// Direct autocomplete initialization as fallback
function initializeClergyAutocompleteDirect(input) {
    if (input.hasAttribute('data-autocomplete-initialized')) {
        return;
    }
    
    const dropdown = input.parentElement.querySelector('.autocomplete-dropdown');
    if (!dropdown) {
        return;
    }
    
    input.setAttribute('data-autocomplete-initialized', 'true');
    
    input.addEventListener('input', function() {
        const query = this.value.trim();
        
        if (query.length < 2) {
            dropdown.style.display = 'none';
            return;
        }
        
        // Use fetch for direct initialization
        fetch(`/api/search_bishops?q=${encodeURIComponent(query)}`)
            .then(response => response.text())
            .then(html => {
                dropdown.innerHTML = html;
                dropdown.style.display = 'block';
                
                // Attach click handlers
                const results = dropdown.querySelectorAll('.bishop-search-result');
                results.forEach(result => {
                    result.addEventListener('click', function() {
                        const bishopId = this.dataset.id;
                        const bishopName = this.dataset.displayName || this.dataset.name;
                        
                        input.value = bishopName;
                        const hiddenInput = input.parentElement.querySelector('input[type="hidden"]');
                        if (hiddenInput) {
                            hiddenInput.value = bishopId;
                            hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                        
                        dropdown.style.display = 'none';
                    });
                });
            })
            .catch(error => {
                console.error('Error fetching bishops:', error);
            });
    });
    
    input.addEventListener('blur', function() {
        setTimeout(() => {
            dropdown.style.display = 'none';
        }, 200);
    });
    
    input.addEventListener('focus', function() {
        if (this.value.trim().length >= 2) {
            this.dispatchEvent(new Event('input'));
        }
    });
}

// Simple instant notification system
function showNotification(message, type = 'info') {
    // Optionally show a very brief, instant alert that auto-closes
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? 'rgba(46, 160, 67, 0.9)' : 'rgba(231, 76, 60, 0.9)'};
        color: white;
        padding: 0.5em 1em;
        border-radius: 4px;
        z-index: 9999;
        font-size: 0.8em;
        opacity: 1;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Auto remove quickly
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 1500);
}

</script>