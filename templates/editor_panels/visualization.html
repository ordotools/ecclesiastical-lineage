<!-- Visualization Panel Content -->
{% if error_message %}
<div style="padding: 2em; text-align: center; color: rgba(255, 100, 100, 0.9);">
    <i class="fas fa-exclamation-triangle" style="font-size: 2em; margin-bottom: 0.5em;"></i>
    <div>{{ error_message }}</div>
</div>
{% else %}
<div id="editor-graph-container" style="width: 100%; height: 100%; position: relative;">
    <!-- Graph will be rendered here by D3.js -->
</div>

<script>
(function() {
    // Data from the server
    const nodesData = {{ nodes_json | safe }};
    const linksData = {{ links_json | safe }};
    
    console.log('Editor visualization - Nodes:', nodesData.length, 'Links:', linksData.length);
    
    // Initialize the visualization
    function initializeVisualization() {
        const container = document.getElementById('editor-graph-container');
        if (!container || !d3) {
            console.log('Container or D3 not available, retrying...');
            setTimeout(initializeVisualization, 100);
            return;
        }
        
        // Clear any existing SVG
        d3.select(container).selectAll('*').remove();
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Create SVG
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // Create zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', function(event) {
                g.attr('transform', event.transform);
            });
        
        svg.call(zoom);
        
        // Create main group for zooming/panning
        const g = svg.append('g');
        
        // Create simulation
        const simulation = d3.forceSimulation(nodesData)
            .force('link', d3.forceLink(linksData).id(d => d.id).distance(150))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(30));
        
        // Create links
        const link = g.append('g')
            .selectAll('line')
            .data(linksData)
            .enter().append('line')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.7);
        
        // Create nodes
        const node = g.append('g')
            .selectAll('circle')
            .data(nodesData)
            .enter().append('circle')
            .attr('r', d => d.rank === 'Pope' ? 20 : 15)
            .attr('fill', d => d.color)
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))
            .on('click', function(event, d) {
                // Select clergy when clicked
                if (typeof window.selectClergy === 'function') {
                    window.selectClergy(d.id);
                }
                
                // Highlight selected node
                node.attr('stroke-width', 2).attr('stroke', '#fff');
                d3.select(this).attr('stroke-width', 4).attr('stroke', '#ffd700');
            });
        
        // Add node labels
        const label = g.append('g')
            .selectAll('text')
            .data(nodesData)
            .enter().append('text')
            .text(d => d.name)
            .attr('font-size', '12px')
            .attr('font-family', 'Inter, sans-serif')
            .attr('fill', 'rgba(255, 255, 255, 0.9)')
            .attr('text-anchor', 'middle')
            .attr('dy', 35)
            .style('pointer-events', 'none')
            .style('text-shadow', '1px 1px 2px rgba(0, 0, 0, 0.7)');
        
        // Update positions on simulation tick
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            
            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
            
            label
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });
        
        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Center the graph initially
        setTimeout(() => {
            const bounds = g.node().getBBox();
            const fullWidth = width;
            const fullHeight = height;
            const midX = bounds.x + bounds.width / 2;
            const midY = bounds.y + bounds.height / 2;
            
            if (bounds.width === 0 || bounds.height === 0) return;
            
            const scale = 0.8 / Math.max(bounds.width / fullWidth, bounds.height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
            
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }, 1000);
        
        // Make the visualization responsive
        function handleResize() {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;
            
            svg
                .attr('width', newWidth)
                .attr('height', newHeight);
            
            simulation
                .force('center', d3.forceCenter(newWidth / 2, newHeight / 2))
                .alpha(0.3)
                .restart();
        }
        
        // Listen for window resize
        window.addEventListener('resize', handleResize);
        
        // Store cleanup function
        container._cleanup = () => {
            window.removeEventListener('resize', handleResize);
            simulation.stop();
        };
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeVisualization);
    } else {
        initializeVisualization();
    }
    
    // Cleanup on panel reload
    const container = document.getElementById('editor-graph-container');
    if (container && container._cleanup) {
        container._cleanup();
    }
})();
</script>
{% endif %}