{% extends "base.html" %}

{% block title %}Lineage Visualization - Ecclesiastical Lineage{% endblock %}

{% block full_content %}
    <!-- Legend and controls remain unchanged -->
    <div class="container mt-4">
        <!-- Legend -->
        <div class="legend position-absolute top-0 start-0 m-3 p-3 glass-morphism rounded legend-visualization">
            <h6 class="fw-bold mb-2 text-dark">Lineage Types</h6>
            <div class="d-flex align-items-center mb-2">
                <div style="width: 20px; height: 2px; background: #000000; margin-right: 8px;"></div>
                <small class="text-dark">Ordination</small>
            </div>
            <div class="d-flex align-items-center mb-2">
                <div style="width: 20px; height: 2px; background: #27ae60; margin-right: 8px;"></div>
                <small class="text-dark">Consecration</small>
            </div>
            <div class="d-flex align-items-center mb-2">
                <div style="width: 20px; height: 2px; background: #27ae60; border-top: 2px dotted #27ae60; margin-right: 8px;"></div>
                <small class="text-dark">Co-consecration</small>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls position-absolute top-0 end-0 m-3 p-3 glass-morphism rounded visualization-controls">
            <button id="reset-zoom" class="btn btn-sm btn-outline-secondary mb-2 w-100">
                <i class="fas fa-search-plus me-1"></i>Reset Zoom
            </button>
            <button id="center-graph" class="btn btn-sm btn-outline-secondary w-100">
                <i class="fas fa-crosshairs me-1"></i>Center Graph
            </button>
        </div>

        <!-- Admin Navigation Button -->
        {% if session.is_admin %}
        <div class="position-absolute bottom-0 end-0 m-3 admin-nav-container">
            <a href="{{ url_for('clergy_list') }}" class="btn admin-nav-btn">
                <i class="fas fa-list me-2"></i>Back to Clergy List
            </a>
        </div>
        {% endif %}

        <!-- Graph Container -->
        <div id="graph-container" class="graph-container-full"></div>
    </div>
{% endblock %}

{% block extra_styles %}
{% endblock %}

{% block extra_scripts %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    // Specify the dimensions of the chart
    const width = window.innerWidth;
    const height = window.innerHeight - 76;

    // The force simulation mutates links and nodes, so create a copy
    const links = {{ links | safe }}.map(d => ({...d}));
    const nodes = {{ nodes | safe }}.map(d => ({...d}));

    // Function to detect and offset parallel links
    function processParallelLinks(links) {
        // Group links by source-target pairs
        const linkGroups = {};
        
        links.forEach(link => {
            const key = `${link.source}-${link.target}`;
            if (!linkGroups[key]) {
                linkGroups[key] = [];
            }
            linkGroups[key].push(link);
        });
        
        // Add offset to parallel links
        Object.values(linkGroups).forEach(group => {
            if (group.length > 1) {
                // Sort by type to ensure consistent ordering
                group.sort((a, b) => {
                    const typeOrder = { 'ordination': 0, 'consecration': 1, 'co-consecration': 2 };
                    return (typeOrder[a.type] || 0) - (typeOrder[b.type] || 0);
                });
                
                // Calculate offset for each link
                const offset = 8; // Distance between parallel lines
                const totalOffset = (group.length - 1) * offset / 2;
                
                group.forEach((link, index) => {
                    link.parallelIndex = index;
                    link.parallelOffset = (index * offset) - totalOffset;
                });
            } else {
                group[0].parallelIndex = 0;
                group[0].parallelOffset = 0;
            }
        });
        
        return links;
    }

    // Process links to handle parallel connections
    const processedLinks = processParallelLinks(links);

    // Create a simulation with several forces
    const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(processedLinks).id(d => d.id).distance(144))
        .force("charge", d3.forceManyBody().strength(-400))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(48))
        .on("tick", ticked);

    // Create the SVG container
    const svg = d3.select("#graph-container")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .attr("style", "max-width: 100%; height: auto;");

    // Add zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", function(event) {
            container.attr("transform", event.transform);
        });
    svg.call(zoom);
    const container = svg.append("g");

    // Add arrow markers
    const defs = svg.append("defs");
    defs.append("marker")
        .attr("id", "arrowhead-black")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 12)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .attr("markerUnits", "strokeWidth")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#000000");
    
    defs.append("marker")
        .attr("id", "arrowhead-green")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 12)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .attr("markerUnits", "strokeWidth")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#27ae60");

    // Add a line for each link
    const link = container.append("g")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6)
        .selectAll()
        .data(processedLinks)
        .join("line")
        .attr("stroke-width", 3.2)
        .attr("stroke", d => d.color)
        .attr("stroke-dasharray", d => d.dashed ? "5,5" : "none")
        .attr("marker-end", d => {
            if (d.color === "#000000") return "url(#arrowhead-black)";
            if (d.color === "#27ae60") return "url(#arrowhead-green)";
            return "url(#arrowhead-black)";
        });

    // Link labels removed for cleaner visualization

    // Add a circle for each node
    const node = container.append("g")
        .selectAll()
        .data(nodes)
        .join("circle")
        .attr("r", 9.6)
        .attr("fill", "rgba(252, 250, 245, 0.95)")
        .attr("stroke", d => {
            // Dark green border for bishops and archbishops
            if (d.rank && (d.rank.toLowerCase().includes('bishop') || d.rank.toLowerCase().includes('archbishop'))) {
                return "#1e5f1e";
            }
            return "#2c3e50";
        })
        .attr("stroke-width", 2.4);

    // Add node labels
    const nodeLabel = container.append("g")
        .selectAll()
        .data(nodes)
        .join("text")
        .attr("class", "node-label")
        .attr("dy", 25)
        .text(d => d.name);

    // Add tooltips
    node.append("title")
        .text(d => d.name);

    // Add a drag behavior
    node.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    // Add tooltip behavior - only show on click, not hover
    let isDragging = false;
    let clickedNode = null;
    
    node.on("mousedown", function(event, d) {
        isDragging = false;
        clickedNode = d;
    })
    .on("mousemove", function(event, d) {
        if (clickedNode === d) {
            isDragging = true;
        }
    })
    .on("mouseup", function(event, d) {
        if (clickedNode === d && !isDragging) {
            // Show tooltip only if clicked without dragging
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
            
            tooltip.transition()
                .duration(200)
                .style("opacity", .9);
            tooltip.html(
                "<h6>" + d.name + "</h6>" +
                "<p><strong>Rank:</strong> " + (d.rank || 'N/A') + "</p>" +
                "<p><strong>Organization:</strong> " + (d.organization || 'N/A') + "</p>"
            )
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        }
        clickedNode = null;
        isDragging = false;
    });

    // Set the position attributes of links and nodes each time the simulation ticks
    function ticked() {
        link
            .attr("x1", d => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const angle = Math.atan2(dy, dx);
                const offsetX = Math.cos(angle + Math.PI/2) * d.parallelOffset;
                const offsetY = Math.sin(angle + Math.PI/2) * d.parallelOffset;
                return d.source.x + offsetX;
            })
            .attr("y1", d => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const angle = Math.atan2(dy, dx);
                const offsetX = Math.cos(angle + Math.PI/2) * d.parallelOffset;
                const offsetY = Math.sin(angle + Math.PI/2) * d.parallelOffset;
                return d.source.y + offsetY;
            })
            .attr("x2", d => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const angle = Math.atan2(dy, dx);
                const offsetX = Math.cos(angle + Math.PI/2) * d.parallelOffset;
                const offsetY = Math.sin(angle + Math.PI/2) * d.parallelOffset;
                return d.target.x + offsetX;
            })
            .attr("y2", d => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const angle = Math.atan2(dy, dx);
                const offsetX = Math.cos(angle + Math.PI/2) * d.parallelOffset;
                const offsetY = Math.sin(angle + Math.PI/2) * d.parallelOffset;
                return d.target.y + offsetY;
            });



        node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

        nodeLabel
            .attr("x", d => d.x)
            .attr("y", d => d.y);
    }

    // Reheat the simulation when drag starts, and fix the subject position
    function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
    }

    // Update the subject (dragged node) position during drag
    function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
    }

    // Restore the target alpha so the simulation cools after dragging ends
    // Unfix the subject position now that it's no longer being dragged
    function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
    }

    // Control buttons
    document.getElementById("reset-zoom").addEventListener("click", function() {
        svg.transition().duration(750).call(
            zoom.transform,
            d3.zoomIdentity
        );
    });

    document.getElementById("center-graph").addEventListener("click", function() {
        simulation.force("center", d3.forceCenter(width / 2, height / 2));
        simulation.alpha(1).restart();
    });

    // Handle window resize
    window.addEventListener("resize", function() {
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight - 76;
        svg.attr("width", newWidth).attr("height", newHeight);
        simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
        simulation.alpha(1).restart();
    });

    // Handle logout redirect
    document.body.addEventListener('htmx:afterRequest', function(evt) {
        if (evt.detail.xhr.status === 200) {
            const response = evt.detail.xhr.responseText;
            if (response.includes('logout')) {
                const redirectDiv = evt.detail.target.querySelector('#redirect');
                if (redirectDiv) {
                    const url = redirectDiv.getAttribute('data-url');
                    setTimeout(function() {
                        window.location.href = url;
                    }, 1000);
                }
            }
        }
    });
</script>
{% endblock %} 